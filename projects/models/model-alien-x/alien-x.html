<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alien X - Final Form</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffffff; font-family: 'Segoe UI', sans-serif; font-size: 14px; pointer-events: none;
            letter-spacing: 3px; text-transform: uppercase; font-weight: bold;
            text-shadow: 0 0 15px #ffffff;
        }
        #controls {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #888; font-family: sans-serif; font-size: 11px; pointer-events: none;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div id="loading">Restoring Celestial Texture...</div>
    <div id="controls">DRAG TO ROTATE â€¢ SCROLL TO ZOOM</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Configuration ---
        const CONFIG = {
            bgColor: 0x010101, // Pure black void
            eyeColor: 0xccffcc,
            omnitrixColor: 0x55ff55
        };

        // --- Global Variables ---
        let scene, camera, renderer, clock;
        let alienGroup, starUniforms;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };

        // --- Shader (Restored from "High Fidelity" Version) ---

        const celestialVertexShader = `
            varying vec3 vWorldPosition;
            varying vec3 vNormal;

            void main() {
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const celestialFragmentShader = `
            uniform float uTime;
            uniform vec2 uResolution;
            varying vec3 vWorldPosition;
            varying vec3 vNormal;

            // Simplex Noise (The "Perfect" Organic Look)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            void main() {
                // View-based mapping for the "Window to Space" effect
                vec3 viewDir = normalize(vWorldPosition - cameraPosition);
                vec2 skyUV = viewDir.xy * 0.9;

                // 1. Deep Space Base
                vec3 color = vec3(0.0, 0.0, 0.02);

                // 2. Organic Nebulas (Blue/Purple Mix)
                float n1 = snoise(skyUV * 3.0 + uTime * 0.05);
                float n2 = snoise(skyUV * 6.0 - uTime * 0.02);

                vec3 purple = vec3(0.12, 0.0, 0.35);
                vec3 blue = vec3(0.0, 0.15, 0.45);
                vec3 nebulaColor = mix(purple, blue, n2);

                // Add nebula clouds
                color += nebulaColor * smoothstep(0.1, 0.9, n1) * 0.7;

                // 3. Stars (Multi-layered)
                float stars1 = step(0.99, snoise(skyUV * 40.0)); // Big bright stars
                float stars2 = step(0.95, snoise(skyUV * 120.0)); // Small clusters

                // Twinkle effect
                float twinkle = sin(skyUV.x * 50.0 + uTime * 2.0) * 0.5 + 0.5;

                color += vec3(stars1) * 1.0;
                color += vec3(stars2) * 0.4 * twinkle;

                // 4. Rim Light (Crucial for the silhouette)
                float fresnel = pow(1.0 - max(dot(vNormal, vec3(0.0, 0.0, 1.0)), 0.0), 3.0);
                float rim = 1.0 - max(dot(viewDir, -vNormal), 0.0);
                rim = pow(rim, 2.2);

                vec3 rimColor = vec3(0.8, 0.9, 1.0) * rim * 1.0;

                gl_FragColor = vec4(color + rimColor, 1.0);
            }
        `;

        // --- Init ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.bgColor);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0.5, 6.5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            buildScene();

            // Interaction
            window.addEventListener('resize', onResize);
            document.addEventListener('mousedown', e => { isDragging = true; previousMousePosition = {x: e.clientX, y: e.clientY}; });
            document.addEventListener('mouseup', () => isDragging = false);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', e => { camera.position.z = Math.max(3, Math.min(camera.position.z + e.deltaY * 0.01, 12)); });
            document.addEventListener('touchstart', e => { if(e.touches.length===1) { isDragging=true; previousMousePosition={x:e.touches[0].clientX, y:e.touches[0].clientY}; } });
            document.addEventListener('touchend', () => isDragging = false);
            document.addEventListener('touchmove', onTouchMove);

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function buildScene() {
            alienGroup = new THREE.Group();
            scene.add(alienGroup);

            starUniforms = {
                uTime: { value: 0 },
                uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            };

            const cosmicMat = new THREE.ShaderMaterial({
                uniforms: starUniforms,
                vertexShader: celestialVertexShader,
                fragmentShader: celestialFragmentShader,
            });

            // --- IMPROVED ANATOMY ---

            // 1. Head (More Iconic Shape)
            const headGrp = new THREE.Group();
            headGrp.position.y = 1.55;

            // Main Cranium (Smoother)
            const skull = new THREE.Mesh(new THREE.SphereGeometry(0.24, 64, 64), cosmicMat);
            skull.scale.set(0.95, 1.2, 1.05);
            headGrp.add(skull);

            // Chin (Better integration)
            const chin = new THREE.Mesh(new THREE.SphereGeometry(0.12, 32, 32), cosmicMat);
            chin.position.set(0, -0.25, 0.06);
            chin.scale.set(1, 1.2, 1);
            headGrp.add(chin);

            // Jawline Fillers (To hide the seam between skull and chin)
            const jawL = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), cosmicMat);
            jawL.position.set(0.12, -0.15, 0.02);
            headGrp.add(jawL);
            const jawR = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), cosmicMat);
            jawR.position.set(-0.12, -0.15, 0.02);
            headGrp.add(jawR);

            // Center Horn (Fin-like)
            const hornC = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.55, 32), cosmicMat);
            hornC.position.set(0, 0.4, 0.05);
            hornC.rotation.x = -0.2;
            headGrp.add(hornC);

            // Side Horns (Better Curve approximation)
            function createHorn(sign) {
                const h = new THREE.Group();
                h.position.set(sign * 0.15, 0.35, -0.05);
                h.rotation.z = sign * -0.5; // Base angle
                h.rotation.x = -0.2;

                const seg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.25, 16), cosmicMat);
                seg1.position.y = 0.125;
                h.add(seg1);

                const seg2 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.3, 16), cosmicMat);
                seg2.position.set(sign * 0.05, 0.35, 0);
                seg2.rotation.z = sign * 0.3; // Curve inward
                h.add(seg2);
                return h;
            }
            headGrp.add(createHorn(1));
            headGrp.add(createHorn(-1));

            // Eyes (Glowing Sprites preserved)
            const eyeGeo = new THREE.SphereGeometry(0.05, 16, 16);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(0.11, 0.05, 0.21);
            eyeL.scale.set(1.2, 0.5, 0.5);
            eyeL.rotation.z = 0.15;
            headGrp.add(eyeL);

            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(-0.11, 0.05, 0.21);
            eyeR.scale.set(1.2, 0.5, 0.5);
            eyeR.rotation.z = -0.15;
            headGrp.add(eyeR);

            // Glows
            const spriteMat = new THREE.SpriteMaterial({
                map: createGlowTexture(CONFIG.eyeColor),
                color: CONFIG.eyeColor, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending
            });
            const glowL = new THREE.Sprite(spriteMat); glowL.scale.set(0.5, 0.5, 1); eyeL.add(glowL);
            const glowR = new THREE.Sprite(spriteMat); glowR.scale.set(0.5, 0.5, 1); eyeR.add(glowR);

            alienGroup.add(headGrp);

            // 2. Muscular Torso (V-Taper)
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.22, 0.3, 32), cosmicMat);
            neck.position.y = 1.35;
            alienGroup.add(neck);

            // Pecs (Massive)
            const pecGeo = new THREE.SphereGeometry(0.45, 32, 32);
            pecGeo.scale(1, 0.8, 0.5);
            const pecL = new THREE.Mesh(pecGeo, cosmicMat);
            pecL.position.set(0.24, 1.15, 0.15);
            pecL.rotation.z = -0.15;
            alienGroup.add(pecL);
            const pecR = new THREE.Mesh(pecGeo, cosmicMat);
            pecR.position.set(-0.24, 1.15, 0.15);
            pecR.rotation.z = 0.15;
            alienGroup.add(pecR);

            // Upper Back/Traps filler
            const upperBack = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 0.6, 32), cosmicMat);
            upperBack.position.set(0, 1.1, -0.1);
            upperBack.scale.x = 1.2;
            alienGroup.add(upperBack);

            // Core/Abs (Tapered Cylinder)
            const core = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.35, 0.8, 32), cosmicMat);
            core.position.y = 0.6;
            core.scale.z = 0.8;
            alienGroup.add(core);

            // Hips
            const hips = new THREE.Mesh(new THREE.SphereGeometry(0.38, 32, 32), cosmicMat);
            hips.position.y = 0.1;
            hips.scale.y = 0.8;
            alienGroup.add(hips);

            // 3. Limbs (Arms)
            const armL = createLimb(1, cosmicMat);
            const armR = createLimb(-1, cosmicMat);
            alienGroup.add(armL);
            alienGroup.add(armR);

            // 4. Limbs (Legs)
            const legL = createLeg(1, cosmicMat);
            const legR = createLeg(-1, cosmicMat);
            alienGroup.add(legL);
            alienGroup.add(legR);

            // 5. Omnitrix (Center Chest)
            const badge = createOmnitrix();
            badge.position.set(0, 1.15, 0.45);
            badge.rotation.x = -0.15;
            alienGroup.add(badge);

            // Particles (Subtle cosmic dust)
            const partGeo = new THREE.BufferGeometry();
            const partPos = [];
            for(let i=0; i<100; i++) {
                partPos.push((Math.random()-0.5)*4, (Math.random()-0.5)*5, (Math.random()-0.5)*3);
            }
            partGeo.setAttribute('position', new THREE.Float32BufferAttribute(partPos, 3));
            const partMat = new THREE.PointsMaterial({ color: 0xaaaaff, size: 0.05, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
            const particles = new THREE.Points(partGeo, partMat);
            alienGroup.add(particles);
            alienGroup.userData = { head: headGrp, armL, armR, legL, legR, particles, glowSprite: badge.userData.glow };

            // Background Stars
            buildStars();
        }

        function createLimb(sign, mat) {
            const grp = new THREE.Group();
            grp.position.set(sign * 0.65, 1.25, 0);

            // Deltoid (Shoulder Cap)
            const delt = new THREE.Mesh(new THREE.SphereGeometry(0.36, 32, 32), mat);
            grp.add(delt);

            // Bicep/Tricep
            const bicep = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.18, 0.6, 24), mat);
            bicep.position.y = -0.4;
            grp.add(bicep);

            // Elbow Joint
            const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.19, 24, 24), mat);
            elbow.position.y = -0.75;
            grp.add(elbow);

            // Forearm
            const fore = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.14, 0.7, 24), mat);
            fore.position.y = -1.15;
            grp.add(fore);

            // Hand
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.25, 0.15), mat);
            hand.position.y = -1.6;
            grp.add(hand);

            grp.rotation.z = sign * 0.25;
            return grp;
        }

        function createLeg(sign, mat) {
            const grp = new THREE.Group();
            grp.position.set(sign * 0.25, 0.0, 0); // Connected to hips

            // Thigh (Quad)
            const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.22, 1.0, 24), mat);
            thigh.position.y = -0.5;
            grp.add(thigh);

            // Knee Joint
            const knee = new THREE.Mesh(new THREE.SphereGeometry(0.23, 24, 24), mat);
            knee.position.y = -1.05;
            grp.add(knee);

            // Calf
            const calf = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.15, 0.9, 24), mat);
            calf.position.y = -1.55;
            grp.add(calf);

            // Foot
            const foot = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.4), mat);
            foot.position.y = -2.1;
            foot.position.z = 0.1;
            grp.add(foot);

            grp.rotation.z = sign * 0.08;
            return grp;
        }

        function createOmnitrix() {
            const group = new THREE.Group();
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.13, 0.025, 16, 32), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.2 }));
            group.add(ring);
            const face = new THREE.Mesh(new THREE.CircleGeometry(0.12, 32), new THREE.MeshBasicMaterial({ color: CONFIG.omnitrixColor }));
            group.add(face);
            const triShape = new THREE.Shape();
            triShape.moveTo(-0.1, 0.1); triShape.lineTo(0.1, 0.1); triShape.lineTo(0, 0); triShape.lineTo(-0.1, 0.1);
            const triGeo = new THREE.ShapeGeometry(triShape);
            const triMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const t1 = new THREE.Mesh(triGeo, triMat); t1.position.z = 0.01;
            const t2 = new THREE.Mesh(triGeo, triMat); t2.position.z = 0.01; t2.rotation.z = Math.PI;
            group.add(t1); group.add(t2);

            const spriteMat = new THREE.SpriteMaterial({ map: createGlowTexture(CONFIG.omnitrixColor), color: CONFIG.omnitrixColor, transparent: true, blending: THREE.AdditiveBlending });
            const glow = new THREE.Sprite(spriteMat); glow.scale.set(0.6, 0.6, 1.0); group.add(glow);
            group.userData = { glow };
            return group;
        }

        function createGlowTexture(c) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(0.3, 'rgba(255,255,255,0.5)'); g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function buildStars() {
            const geom = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<3000; i++) pos.push((Math.random()-0.5)*150, (Math.random()-0.5)*150, (Math.random()-0.5)*150);
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            scene.add(new THREE.Points(geom, new THREE.PointsMaterial({color: 0xffffff, size: 0.15, transparent: true, opacity: 0.8})));
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (starUniforms) starUniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        }
        function onMouseMove(e) { if(!isDragging) return; targetRotation.y += (e.clientX - previousMousePosition.x)*0.005; targetRotation.x += (e.clientY - previousMousePosition.y)*0.005; previousMousePosition = {x: e.clientX, y: e.clientY}; }
        function onTouchMove(e) { if(!isDragging) return; targetRotation.y += (e.touches[0].clientX - previousMousePosition.x)*0.01; targetRotation.x += (e.touches[0].clientY - previousMousePosition.y)*0.01; previousMousePosition = {x: e.touches[0].clientX, y: e.touches[0].clientY}; }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            if (starUniforms) starUniforms.uTime.value = time;
            if (alienGroup) {
                alienGroup.position.y = Math.sin(time * 0.5) * 0.15;
                alienGroup.rotation.y += (targetRotation.y - alienGroup.rotation.y) * 0.1;
                alienGroup.rotation.x += (targetRotation.x - alienGroup.rotation.x) * 0.1;
                const power = 1 + Math.sin(time * 3) * 0.01; alienGroup.scale.set(power, power, power);
                alienGroup.userData.particles.rotation.y = time * 0.1;
                if(alienGroup.userData.glowSprite) alienGroup.userData.glowSprite.material.opacity = 0.8 + Math.sin(time * 4) * 0.2;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
